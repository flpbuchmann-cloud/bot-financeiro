# -*- coding: utf-8 -*-
"""Cota√ß√£o Ativos II

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-pVrL4yKcLPhpJGhswsVv10YCBkCaUA5
"""

!pip install yfinance pandas numpy

import yfinance as yf
import pandas as pd
import numpy as np

tickers = ['FLOA.L', 'SDHA.L', 'ITPS.L', 'ISGAF', 'EMSA.L', 'IUAA.L', 'IB01.L', 'IEAU.AS', 'IBTA.L','CNYA.L','ETHA','VUAA.L','EQAC.SW','GLD','SLV', 'CBU7.L', 'CBU0.L', 'DTLA.L', 'VDEA.L', 'AGGU.L', 'FLOT', 'SHY', 'IEI', 'IEF', 'TUA', 'TLH', 'TLT', 'TBX', 'IGIB', 'IGLB', 'AGG', 'GLAD.L', 'HYG', 'EMB', 'TBT', 'RSP', 'SPY', 'SPXU', 'SQQQ', 'QQQ', 'IETC', 'IJR', 'VIXY', 'XLK', 'XLV', 'XLY', 'XLF', 'XLC', 'XLI', 'XLP', 'XLE', 'XLU', 'XLRE', 'XLB', 'HDV', 'DBMF', 'UUP', 'FXE', 'IBIT', 'MCHI', 'USO', 'FAN', 'XBI', 'XOP', 'URNM', 'SMH', 'ISVVF', 'IGLN.L', 'VEU', 'VGK', 'EMUU.L', 'FXC','SHYG','AOA','AOM','AOK','AOR','VASIX','VSCGX','NEAR']

from datetime import date

data = yf.download(tickers, start="2020-01-01", end=date.today())

returns = data['Close'].pct_change()

monthly_returns = returns.resample('M').apply(lambda x: (1 + x).cumprod() - 1)

def acumulado_periodo(returns, period):
    # Use .prod() on (1 + x) for more robust cumulative product calculation
    return (returns.rolling(window=period).apply(lambda x: (1 + x).prod() - 1))

retorno_3meses = acumulado_periodo(returns, 63)  # Aproximadamente 3 meses (63 dias √∫teis)
retorno_12meses = acumulado_periodo(returns, 252) # Aproximadamente 12 meses (252 dias √∫teis)
retorno_24meses = acumulado_periodo(returns, 504) # Aproximadamente 24 meses (504 dias √∫teis)

from datetime import datetime

def calculate_ytd_return(returns):
    ytd_returns = (returns.groupby(pd.Grouper(freq='YE')).apply(lambda x: (1 + x).cumprod() - 1)).loc[str(datetime.now().year)]
    return ytd_returns

retorno_ytd = calculate_ytd_return(returns)

volatilidade_12meses = returns.rolling(window=252).std() * np.sqrt(252)
volatilidade_24meses = returns.rolling(window=504).std() * np.sqrt(252)

# Calcula a volatilidade anualizada de 12 meses (252 dias √∫teis)
volatilidade_12meses = returns.rolling(window=252).std() * np.sqrt(252)
# Calcula a volatilidade anualizada de 24 meses (504 dias √∫teis)
volatilidade_24meses = returns.rolling(window=504).std() * np.sqrt(252)

tabela = pd.DataFrame({
    'Ticker': tickers,
    'Retorno Acumulado no M√™s': monthly_returns.iloc[-1].values,
    'Retorno Acumulado em 3 Meses': retorno_3meses.iloc[-1].values,
    'Retorno Acumulado no Ano Corrente (YTD)': retorno_ytd.iloc[-1].values,
    'Retorno Acumulado em 12 Meses': retorno_12meses.iloc[-1].values,
    'Retorno Acumulado em 24 Meses': retorno_24meses.iloc[-1].values,
    'Volatilidade em 12 Meses': volatilidade_12meses.iloc[-1].values,
    'Volatilidade em 24 Meses': volatilidade_24meses.iloc[-1].values
})

print(tabela)

monthly_returns = returns.resample('M').apply(lambda x: (1 + x).cumprod() - 1)

def acumulado_periodo(returns, period):
    # Use .prod() on (1 + x) for more robust cumulative product calculation
    return (returns.rolling(window=period).apply(lambda x: (1 + x.astype(float)).prod() - 1))

retorno_3meses = acumulado_periodo(returns, 63)  # Aproximadamente 3 meses (63 dias √∫teis)
retorno_12meses = acumulado_periodo(returns, 252) # Aproximadamente 12 meses (252 dias √∫teis)
retorno_24meses = acumulado_periodo(returns, 504) # Aproximadamente 24 meses (504 dias √∫teis)

volatilidade_12meses = returns.rolling(window=252).std() * np.sqrt(252)
volatilidade_24meses = returns.rolling(window=504).std() * np.sqrt(252)

# Ensure all metric series are aligned with the tickers list before creating the DataFrame
# We can reindex each metric series to match the index of the tickers list (which is just 0..n-1)
# However, since the metrics are calculated based on the returns DataFrame with tickers as columns,
# it's better to ensure the last row extraction is done carefully to maintain alignment.

# A safer approach is to create a dictionary where keys are tickers and values are lists of metrics
metrics_list = []
for ticker in tickers:
    # Get the last available value for each metric for the current ticker, handling potential NaNs
    monthly_ret = monthly_returns[ticker].iloc[-1] if ticker in monthly_returns.columns and not monthly_returns[ticker].empty else np.nan
    ret_3m = retorno_3meses[ticker].iloc[-1] if ticker in retorno_3meses.columns and not retorno_3meses[ticker].empty else np.nan
    ret_ytd = retorno_ytd[ticker].iloc[-1] if ticker in retorno_ytd.columns and not retorno_ytd[ticker].empty else np.nan
    ret_12m = retorno_12meses[ticker].iloc[-1] if ticker in retorno_12meses.columns and not retorno_12meses[ticker].empty else np.nan
    ret_24m = retorno_24meses[ticker].iloc[-1] if ticker in retorno_24meses.columns and not retorno_24meses[ticker].empty else np.nan
    vol_12m = volatilidade_12meses[ticker].iloc[-1] if ticker in volatilidade_12meses.columns and not volatilidade_12meses[ticker].empty else np.nan
    vol_24m = volatilidade_24meses[ticker].iloc[-1] if ticker in volatilidade_24meses.columns and not volatilidade_24meses[ticker].empty else np.nan

    metrics_list.append({
        'Ticker': ticker,
        'Retorno Acumulado no M√™s': monthly_ret,
        'Retorno Acumulado em 3 Meses': ret_3m,
        'Retorno Acumulado no Ano Corrente (YTD)': ret_ytd,
        'Retorno Acumulado em 12 Meses': ret_12m,
        'Retorno Acumulado em 24 Meses': ret_24m,
        'Volatilidade em 12 Meses': vol_12m,
        'Volatilidade em 24 Meses': vol_24m
    })

tabela = pd.DataFrame(metrics_list)

print(tabela)

# Check data types of columns in returns
print(returns.dtypes)

# Check for missing values
print(returns.isnull().sum())

# Fill missing values with 0 or a forward/backward fill, or drop rows/columns with NaNs
# For this case, let's try filling NaNs with 0 as returns are likely 0 on days without trading data
returns_cleaned = returns.fillna(0)

# Re-run the calculations with the cleaned data
def acumulado_periodo(returns, period):
    # Explicitly convert to numeric within the lambda function
    return (returns.rolling(window=period).apply(lambda x: (1 + x.astype(float)).prod() - 1))

retorno_3meses = acumulado_periodo(returns_cleaned, 63)  # Aproximadamente 3 meses (63 dias √∫teis)
retorno_12meses = acumulado_periodo(returns_cleaned, 252) # Aproximadamente 12 meses (252 dias √∫teis)
retorno_24meses = acumulado_periodo(returns_cleaned, 504) # Aproximadamente 24 meses (504 dias √∫teis)

from datetime import datetime

def calculate_ytd_return(returns):
    # Filter returns for the current year
    current_year = str(datetime.now().year)
    returns_current_year = returns[returns.index.year == int(current_year)]

    # Calculate cumulative returns for the current year
    ytd_returns = (1 + returns_current_year).cumprod() - 1
    return ytd_returns


retorno_ytd = calculate_ytd_return(returns_cleaned)

volatilidade_12meses = returns_cleaned.rolling(window=252).std() * np.sqrt(252)
volatilidade_24meses = returns_cleaned.rolling(window=504).std() * np.sqrt(252)

# Ensure all metric series are aligned with the tickers list before creating the DataFrame
metrics_list = []
for ticker in tickers:
    # Get the last available value for each metric for the current ticker, handling potential NaNs
    monthly_ret = monthly_returns[ticker].iloc[-1] if ticker in monthly_returns.columns and not monthly_returns[ticker].empty else np.nan
    ret_3m = retorno_3meses[ticker].iloc[-1] if ticker in retorno_3meses.columns and not retorno_3meses[ticker].empty else np.nan
    # Check if retorno_ytd for the current ticker is empty before accessing iloc[-1]
    ret_ytd_value = retorno_ytd[ticker].iloc[-1] if ticker in retorno_ytd.columns and not retorno_ytd[ticker].empty else np.nan
    ret_12m = retorno_12meses[ticker].iloc[-1] if ticker in retorno_12meses.columns and not retorno_12meses[ticker].empty else np.nan
    ret_24m = retorno_24meses[ticker].iloc[-1] if ticker in retorno_24meses.columns and not retorno_24meses[ticker].empty else np.nan
    vol_12m = volatilidade_12meses[ticker].iloc[-1] if ticker in volatilidade_12meses.columns and not volatilidade_12meses[ticker].empty else np.nan
    vol_24m = volatilidade_24meses[ticker].iloc[-1] if ticker in volatilidade_24meses.columns and not volatilidade_24meses[ticker].empty else np.nan


    metrics_list.append({
        'Ticker': ticker,
        'Retorno Acumulado no M√™s': monthly_ret,
        'Retorno Acumulado em 3 Meses': ret_3m,
        'Retorno Acumulado no Ano Corrente (YTD)': ret_ytd_value,
        'Retorno Acumulado em 12 Meses': ret_12m,
        'Retorno Acumulado em 24 Meses': ret_24m,
        'Volatilidade em 12 Meses': vol_12m,
        'Volatilidade em 24 Meses': vol_24m
    })

tabela = pd.DataFrame(metrics_list)

print(tabela)

# Step 1: Calculate the daily risk-free rate
# Assume a risk-free rate of 1% (0.01) and convert to daily
risk_free_rate_annual = 0.01
risk_free_rate_daily = risk_free_rate_annual / 252

# Step 2: Calculate the Sharpe Ratio for each ticker
# Calculate average daily returns
average_daily_returns = returns.mean()

# Calculate the daily standard deviation of returns
daily_std_dev = returns.std()

# Calculate the Sharpe Ratio, handle division by zero by replacing it with NaN
sharpe_ratios = (average_daily_returns - risk_free_rate_daily) / daily_std_dev
sharpe_ratios = sharpe_ratios.replace([np.inf, -np.inf], np.nan)


# Annualize the Sharpe Ratio
sharpe_ratios_annualized = sharpe_ratios * np.sqrt(252)


# Step 3 & 4: Define and apply the Maximum Drawdown function
def calculate_maximum_drawdown(returns):
    # Drop NaN values before calculation
    returns_cleaned = returns.dropna()
    if returns_cleaned.empty:
        return np.nan # Return NaN if all values were NaN

    # Calculate cumulative returns, starting with 1
    cumulative_returns = (1 + returns_cleaned).cumprod()

    # Prepend 1 to the cumulative returns series for drawdown calculation
    # Ensure the index is a DatetimeIndex for proper concatenation if applicable
    if isinstance(cumulative_returns.index, pd.DatetimeIndex):
         cumulative_returns = pd.concat([pd.Series([1.0], index=[cumulative_returns.index[0] - pd.Timedelta(days=1)]), cumulative_returns])
    else:
        cumulative_returns = pd.concat([pd.Series([1.0], index=[0]), cumulative_returns])


    # Calculate the running maximum
    running_max = cumulative_returns.cummax()

    # Calculate the drawdown
    drawdown = (cumulative_returns - running_max) / running_max

    # Return the minimum drawdown (most negative value)
    # Return 0 if all values are non-negative (no drawdown)
    return drawdown.min() if not drawdown.empty else 0


# Calculate Maximum Drawdown for each ticker
maximum_drawdowns = returns.apply(calculate_maximum_drawdown)


# Get the last closing price for each ticker
last_close_prices = data['Close'].iloc[-1]


# Step 5: Add the calculated metrics to the tabela DataFrame
tabela['Sharpe Ratio (Annualized)'] = tabela['Ticker'].map(sharpe_ratios_annualized)
tabela['Maximum Drawdown'] = tabela['Ticker'].map(maximum_drawdowns)
tabela['Pre√ßo de Fechamento'] = tabela['Ticker'].map(last_close_prices)


# Display the updated tabela DataFrame with percentage formatting
# Create a dictionary for formatting
format_mapping = {
    'Retorno Acumulado no M√™s': '{:.2%}',
    'Retorno Acumulado em 3 Meses': '{:.2%}',
    'Retorno Acumulado no Ano Corrente (YTD)': '{:.2%}',
    'Retorno Acumulado em 12 Meses': '{:.2%}',
    'Retorno Acumulado em 24 Meses': '{:.2%}',
    'Volatilidade em 12 Meses': '{:.2%}',
    'Volatilidade em 24 Meses': '{:.2%}',
    'Maximum Drawdown': '{:.2%}'
    # Sharpe Ratio is typically not formatted as a percentage
}

# Apply the formatting when displaying the table
display(tabela.style.format(format_mapping))

from datetime import datetime

def calculate_ytd_return(returns):
    # Filter returns for the current year
    current_year = str(datetime.now().year)
    returns_current_year = returns[returns.index.year == int(current_year)]

    # Calculate cumulative returns for the current year
    ytd_returns = (1 + returns_current_year).cumprod() - 1
    return ytd_returns

retorno_ytd = calculate_ytd_return(returns)

print(len(tickers))
print(len(monthly_returns.iloc[-1].values))
print(len(retorno_3meses.iloc[-1].values))
print(len(retorno_ytd.iloc[-1].values))
print(len(retorno_12meses.iloc[-1].values))
print(len(retorno_24meses.iloc[-1].values))
print(len(volatilidade_12meses.iloc[-1].values))
print(len(volatilidade_24meses.iloc[-1].values))

display(retorno_ytd)

display(returns)

display(tabela)

!pip install gspread oauth2client

# Check data types of columns in returns
print(returns.dtypes)

# Check for missing values
print(returns.isnull().sum())

# Fill missing values with 0 or a forward/backward fill, or drop rows/columns with NaNs
# For this case, let's try filling NaNs with 0 as returns are likely 0 on days without trading data
returns_cleaned = returns.fillna(0)

# Replace infinite values with NaN and then fill NaNs with 0
returns_cleaned = returns_cleaned.replace([np.inf, -np.inf], np.nan).fillna(0)


# Re-run the calculations with the cleaned data
def acumulado_periodo(returns, period):
    # Use .prod() on (1 + x) for more robust cumulative product calculation
    return (returns.rolling(window=period).apply(lambda x: (1 + x.astype(float)).prod() - 1))

retorno_3meses = acumulado_periodo(returns_cleaned, 63)  # Aproximadamente 3 meses (63 days)
retorno_12meses = acumulado_periodo(returns_cleaned, 252) # Aproximadamente 12 meses (252 days)
retorno_24meses = acumulado_periodo(returns_cleaned, 504) # Aproximadamente 24 meses (504 days)

from datetime import datetime

def calculate_ytd_return(returns):
    # Calculate cumulative return from the beginning of each year
    return (1 + returns).groupby(returns.index.year).cumprod() - 1


retorno_ytd = calculate_ytd_return(returns_cleaned)

volatilidade_12meses = returns_cleaned.rolling(window=252).std() * np.sqrt(252)
volatilidade_24meses = returns_cleaned.rolling(window=504).std() * np.sqrt(252)

# Ensure monthly_returns is also cleaned
monthly_returns_cleaned = monthly_returns.replace([np.inf, -np.inf], np.nan).fillna(0)

# Get the last closing price for each ticker
last_close_prices = data['Close'].iloc[-1]

# Cria a tabela com os retornos e volatilidades
tabela = pd.DataFrame({
    'Ticker': returns_cleaned.columns,
    'Retorno Acumulado no M√™s': monthly_returns_cleaned.iloc[-1],
    'Retorno Acumulado em 3 Meses': retorno_3meses.iloc[-1],
    'Retorno Acumulado no Ano Corrente (YTD)': retorno_ytd.iloc[-1],
    'Retorno Acumulado em 12 Meses': retorno_12meses.iloc[-1],
    'Retorno Acumulado em 24 Meses': retorno_24meses.iloc[-1],
    'Volatilidade em 12 Meses': volatilidade_12meses.iloc[-1],
    'Volatilidade em 24 Meses': volatilidade_24meses.iloc[-1],
    'Pre√ßo de Fechamento': last_close_prices
})

print(tabela)

from google.colab import sheets
sheet = sheets.InteractiveSheet

# from google.colab import auth
# auth.authenticate_user()

import os
import json
import gspread
# from google.auth import default
# creds, _ = default()

# gc = gspread.authorize(creds)

# Nova forma de autentica√ß√£o usando uma conta de servi√ßo
# Certifique-se de ter feito o upload do seu arquivo JSON de credenciais para o ambiente do Colab
# e substitua 'SEU_ARQUIVO_DE_CREDENCIAIS.json' pelo nome do seu arquivo.
creds_json = json.loads(os.environ['GCP_CREDENTIALS'])
gc = gspread.service_account_from_dict(creds_json)

"""Agora, vamos criar uma nova planilha com o nome "Cota√ß√µes Dia" e carregar o DataFrame nela."""

# Substitua o link abaixo pela URL completa da sua planilha
SPREADSHEET_URL = 'https://docs.google.com/spreadsheets/d/1l7JRylHrYqPmtC4qxGuLaAMRHUvJOVb_jEc4Px1qOJ4/edit?gid=0#gid=0'

if SPREADSHEET_URL == 'INSIRA_A_URL_DA_SUA_PLANILHA_AQUI':
    print("‚ö†Ô∏è ATEN√á√ÉO: Voc√™ precisa substituir o texto 'INSIRA_A_URL_DA_SUA_PLANILHA_AQUI' pela URL real da sua planilha na linha acima! ‚ö†Ô∏è")
else:
    try:
        # Abre a planilha diretamente pela URL
        sh = gc.open_by_url(SPREADSHEET_URL)

        # Seleciona a primeira planilha (sheet) dentro do arquivo
        worksheet = sh.sheet1

        # Limpa o conte√∫do existente na planilha (opcional)
        # worksheet.clear()

        # Convert DataFrame to list of lists, replacing NaN and infinite values with None for JSON compliance
        data_to_upload = [tabela.columns.tolist()] + tabela.replace([np.inf, -np.inf], np.nan).values.tolist()

        # Replace any remaining NaN values with None explicitly during conversion to list
        data_to_upload = [[None if pd.isna(val) else val for val in row] for row in data_to_upload]

        # Atualiza todos os valores na planilha de uma vez
        worksheet.update(data_to_upload)

        print(f"DataFrame carregado com sucesso na planilha '{sh.title}' (ID: {sh.id})")

    except gspread.SpreadsheetNotFound:
        print("Erro: Planilha n√£o encontrada. Verifique se a URL est√° correta e se a conta de servi√ßo tem acesso.")
    except Exception as e:
        print(f"Ocorreu um erro: {e}")

print("Checking for NaN values in 'tabela':")
print(tabela.isnull().sum())

print("\nChecking for infinite values in 'tabela':")
# Select only numerical columns before checking for infinities
numerical_cols = tabela.select_dtypes(include=np.number)
print(numerical_cols.apply(np.isinf).sum())

display(tabela)

"""# üöÄ Como Configurar no GitHub Actions

Siga este guia para rodar seu script automaticamente na nuvem usando o GitHub Actions.

### 1. Preparar os Arquivos
Crie uma pasta no seu computador e coloque:
*   `financeiro.py` (Seu script, baixado do Colab).
*   `requirements.txt` (Crie este arquivo texto e escreva nele: `yfinance pandas numpy gspread oauth2client`).

### 2. Criar o Reposit√≥rio no GitHub
1.  Crie uma conta no [GitHub](https://github.com/) e um novo reposit√≥rio (ex: `bot-financeiro`).
2.  Fa√ßa o upload dos arquivos `financeiro.py` e `requirements.txt` para l√°.

### 3. Configurar a Chave Secreta (IMPORTANTE)
N√£o envie seu arquivo JSON (`minhachavejson.json`) para o reposit√≥rio p√∫blico! Use as "Secrets":
1.  No seu reposit√≥rio, v√° em **Settings** > **Secrets and variables** > **Actions**.
2.  Clique em **New repository secret**.
3.  **Name:** `GCP_CREDENTIALS`
4.  **Secret:** Cole todo o conte√∫do do seu arquivo JSON (`minhachavejson.json`) aqui.
5.  Clique em **Add secret**.

### 4. Ajustar o Script Python
Edite seu arquivo `financeiro.py` para ler a chave da vari√°vel de ambiente em vez do arquivo:
```python
import os
import json
import gspread

# ... (c√≥digo anterior)

# Carrega as credenciais da vari√°vel de ambiente
creds_json = json.loads(os.environ['GCP_CREDENTIALS'])
gc = gspread.service_account_from_dict(creds_json)

# ... (resto do c√≥digo)
```

### 5. Criar o Workflow (O Agendamento)
1.  No seu reposit√≥rio, clique em **Actions** > **New workflow** > **set up a workflow yourself**.
2.  Nomeie o arquivo como `.github/workflows/execucao_diaria.yml`.
3.  Cole o conte√∫do abaixo (Aten√ß√£o ao hor√°rio: 08:30 BRT = 11:30 UTC):

```yaml
name: Atualizar Planilha Financeira

on:
  schedule:
    # Roda √†s 11:30 UTC (08:30 Bras√≠lia) de Segunda a Sexta (1-5)
    - cron: '30 11 * * 1-5'
  workflow_dispatch: # Permite rodar manualmente clicando num bot√£o

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout do c√≥digo
        uses: actions/checkout@v3

      - name: Configurar Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Instalar depend√™ncias
        run: |
          pip install -r requirements.txt

      - name: Executar script
        env:
          GCP_CREDENTIALS: ${{ secrets.GCP_CREDENTIALS }}
        run: python financeiro.py
```
4.  Clique em **Commit changes**.

Pronto! O GitHub vai rodar seu script automaticamente nos hor√°rios definidos.
"""

# Cria o arquivo requirements.txt necess√°rio para o GitHub Actions
content = """
yfinance
pandas
numpy
gspread
oauth2client
"""

with open('requirements.txt', 'w') as f:
    f.write(content.strip())

print("Arquivo 'requirements.txt' criado com sucesso!\nVerifique na aba 'Arquivos' (√≠cone de pasta √† esquerda) e fa√ßa o download.")

"""# üïí Como Agendar a Execu√ß√£o Autom√°tica

O Google Colab n√£o executa sozinho com o navegador fechado. Para rodar este script automaticamente (ex: Seg-Sex √†s 08:30), siga estes passos para rod√°-lo no seu computador:

### Passo 1: Preparar o Script
1. V√° no menu **Arquivo** > **Fazer Download** > **Fazer Download do .py**.
2. Salve o arquivo em uma pasta do seu computador (ex: `C:\Scripts\financeiro.py`).
3. Mova o seu arquivo de credenciais (`minhachavejson.json` ou `suascredenciais.json`) para a **mesma pasta** do script.

### Passo 2: Instalar Python e Bibliotecas (se n√£o tiver)
1. Instale o Python (python.org).
2. Abra o terminal/CMD e instale as bibliotecas usadas:
   ```bash
   pip install yfinance pandas numpy gspread oauth2client
   ```

### Passo 3: Agendar (Windows)
1. Abra o **Agendador de Tarefas** do Windows.
2. Clique em **Criar Tarefa B√°sica**.
3. D√™ um nome (ex: "Atualizar Planilha Financeira").
4. Disparador: **Diariamente** ou **Semanalmente** (selecione os dias).
5. A√ß√£o: **Iniciar um programa**.
   - Programa/script: `python` (ou o caminho completo para `python.exe`).
   - Adicione argumentos: `financeiro.py` (o nome do seu arquivo).
   - Iniciar em: Coloque o caminho da pasta onde salvou o arquivo (ex: `C:\Scripts`).
6. Defina o hor√°rio para 08:30.

### Op√ß√£o Avan√ßada (Nuvem)
Se preferir n√£o deixar seu PC ligado, voc√™ pode usar servi√ßos como **GitHub Actions** (gratuito com limites) ou **PythonAnywhere** (pago para agendamento, mas muito f√°cil de usar).
"""
